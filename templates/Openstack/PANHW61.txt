RUNNING_CFG_PATH=/opt/pancfg/mgmt/saved-configs
RUNNING_CFG=$RUNNING_CFG_PATH/running-config.xml
FACTORY_RUNNING_CFG=$SVM_CFG_XSL_PATH/running-config.xml












if [ -e ${DO_DATA_RESET} ]; then
              # private data reset, save a copy to vm_cfg
              cp $RUNNING_CFG $VM_INIT_CFG_PATH







#! /bin/sh
#
# panhw     Setup PAN hardware
#
# chkconfig: 2345 10 90 
# description: Pan hardware setup

# Source function library.
. /etc/init.d/functions


# sdb variable cfg.general.vm-mode is enum and is defined 
# in sysd_cfg_global.h Any new modes are added then make use 
# you update sysd_cfg_global.h also
#typedef enum {
#    SYSD_VM_MODE_GATEWAY = 0,
#    SYSD_VM_MODE_VMWARE_HYPERVISOR,
#    SYSD_VM_MODE_XEN_SDX,
#    SYSD_VM_MODE_KVM,
#    SYSD_VM_MODE_XEN_AWS,
#} sysd_vm_mode_types_t;


SYSD_VM_MODE_GATEWAY=0
SYSD_VM_MODE_VMWARE_HYPERVISOR=1
SYSD_VM_MODE_XEN_SDX=2
SYSD_VM_MODE_KVM=3
SYSD_VM_MODE_XEN_AWS=4

EECFG="/etc/cfgdb/eeprom.xml"
NET_ETH0="/sys/class/net/eth0"
portcount=24

DO_DATA_RESET=/opt/panrepo/private_data_reset     # flag for private data reset
LICENSE_LOG_FILE="/var/log/pan/pan_license.log"
LICENSE_FILES="/opt/pancfg/mgmt/licenses/PA_VM*.key"
PUB_PEM="/opt/pancfg/mgmt/global/pub.pem"
LICENSE_FILE_SIZE=400000
VMWARE_SVM_CFG_FILE=ovf-env.xml
SVM_CFG_XSL_PATH=/opt/paninstall/mgmt/factory
SVM_CFG_XSL_FILE=$SVM_CFG_XSL_PATH/svm-cfg-transform.xsl
VM_INIT_CFG_XSL_FILE=$SVM_CFG_XSL_PATH/vm-initcfg-transform.xsl
VM_INIT_CFG_PATH=/opt/pancfg/mgmt/vm_cfg
VM_INIT_CFG_FILE=$VM_INIT_CFG_PATH/init_cfg.txt
BOOTSTRAP_NETWORK_CFG_FILE=bootstrap-networkconfig.xml
RUNNING_CFG_PATH=/opt/pancfg/mgmt/saved-configs
RUNNING_CFG=$RUNNING_CFG_PATH/running-config.xml
FACTORY_RUNNING_CFG=$SVM_CFG_XSL_PATH/running-config.xml
AWS_CFG_XSL_FILE=$SVM_CFG_XSL_PATH/aws-cfg-transform.xsl

vm_mode=`/usr/local/bin/sysd -x cfg.general.vm-mode 2> /dev/null`
capacity=0
virt_host=""

# determine number of cores
core_count=`cat /proc/cpuinfo | grep -c processor`

#determine number of interfaces
nic_num=`ifconfig -a | grep -c eth`

# get date 
dt=`date +%Y/%m/%d`


vmxnet3_nic=0

set_host_info() {
    AWS_PAVM=0
    if [ -f /sys/hypervisor/version/extra ]; then
        grep amazon /sys/hypervisor/version/extra >/dev/null
        if [ $? == 0 ]; then
            AWS_PANVM=1
            HOST_TYPE="amazon"
            uuid=`cat /sys/hypervisor/uuid | tr [:lower:] [:upper:]`
            cpuid='AWSVMSERIES'
            return
        fi
    fi
    #determine UUID
    uuid=`/usr/sbin/dmidecode -s system-uuid`
    HOST_TYPE=`/usr/sbin/dmidecode -s system-manufacturer`

    #determine cpu id
    cpuid=`/usr/sbin/dmidecode -t processor | grep -m 1 ID | awk '{$1="";$0=substr($0,2)}1'`
    cpuid=`echo $cpuid | tr -d ' '`

}

#determine amount of memory in kB
memory=`cat /proc/meminfo | grep MemTotal | awk '{print $2}'`

get_shared_mem_size() {
    shared_mem=2048M

    #calulate shared memory size based on available phy memory
    #and vm capability
    if [ $1 == 1 ] && [ $2 -gt 5000000 ]; then
       shared_mem=2560M
    fi

    echo "$shared_mem"
}


check_net() {
    if [ ! -d "$NET_ETH0" ]; then
        echo "Management ethernet not found!  Restarting..."
        rm -f /etc/udev/rules.d/70-persistent-net.rules
        /sbin/reboot
    fi

    if [ $virt_host = "KVM" ]; then
        /sbin/vm_pan_gen_udev
    fi
}

check_cdrom () {
    local vm_cdrom=0
    if awk '{print $2}' /proc/mounts | grep -qs "^/mnt/cdrom$"; then
        vm_cdrom=1
    else
        mkdir -p /mnt/cdrom >/dev/null 2>&1
        mount -t iso9660 /dev/cdrom /mnt/cdrom >/dev/null 2>&1
        if [ $? -eq 0 ]; then
            vm_cdrom=1
        fi
    fi

    return $vm_cdrom
}

is_cdrom_ready () {
    check_cdrom
    if [ $? -eq 1 ]; then
        # Verify the cdrom content and tranfrom xml
        if [ -f /mnt/cdrom/$VMWARE_SVM_CFG_FILE ]; then
            mkdir -p $VM_INIT_CFG_PATH >/dev/null 2>&1
            /usr/bin/xsltproc $SVM_CFG_XSL_FILE /mnt/cdrom/$VMWARE_SVM_CFG_FILE >$VM_INIT_CFG_FILE 2>/dev/null
            cp -f /mnt/cdrom/$VMWARE_SVM_CFG_FILE $VM_INIT_CFG_PATH/$VMWARE_SVM_CFG_FILE.`date +%Y%m%d` >/dev/null 2>&1
            if grep -q ip-address $VM_INIT_CFG_FILE >/dev/null 2>&1; then
                echo "1"
                return
            fi
        fi
    fi
    echo "0"
}

UUID_FILE=/opt/pancfg/mgmt/.vm_uuid.txt
is_vm_firstboot () {
    if [ ! -f $UUID_FILE ]; then
        mkdir -p /opt/pancfg/mgmt/
        echo $uuid > $UUID_FILE
        return 1
    fi
    MYUUID=`cat $UUID_FILE`
    if [ X$uuid != X$MYUUID ]; then
        echo $uuid > $UUID_FILE
        return 1
    fi

    return 0
}

vm_hypervisor_init () {
    modprobe vmci &> /dev/null
    modprobe vsock &> /dev/null
    modprobe dvfilterklib &> /dev/null
}

init_log_file () {
    # Rotate pan license log file every 400K
    if [ -f $LICENSE_LOG_FILE ]; then
        file_size=`/bin/ls -s $LICENSE_LOG_FILE | cut -d" " -f 1`
        if [ $file_size -gt $LICENSE_FILE_SIZE ]; then
            /bin/cp -f ${LICENSE_LOG_FILE} ${LICENSE_LOG_FILE}.1
            /bin/rm -f ${LICENSE_LOG_FILE}
        fi
    fi
}

setup_cfgdb() {
    echo -n "*** PAN VM boot time license check - `date` ***"  >> $LICENSE_LOG_FILE
    echo >> $LICENSE_LOG_FILE
    echo "System UUID  $uuid" >> $LICENSE_LOG_FILE
    echo >> $LICENSE_LOG_FILE
    for file in `ls $LICENSE_FILES 2> /dev/null`
    do
      # Initilize following three varibales, because these are set by the license file.
        u=" "
        e="0000/00/00"
        vmcapacity=0
        `cat $file | /usr/bin/openssl base64 -d | \
            /usr/bin/openssl rsautl -verify -pubin -inkey $PUB_PEM | sed -e 's/^/export /' ` 2>/dev/null
        echo "License_file $file" >> $LICENSE_LOG_FILE
        echo "  uuid       $u" >> $LICENSE_LOG_FILE
        echo "  expires    $e" >> $LICENSE_LOG_FILE
        echo "  vmcapacity $vmcapacity" >> $LICENSE_LOG_FILE
        #  if [ ! "$e" \< "$dt" -a "$u" = "$uuid" -a $vmcapacity -gt $capacity ]; then
        #  Do not check expiry date! 
        if [ "$u" = "$uuid" ]; then
            if [ $vmcapacity == "1000-HV" ]; then
                vmcapacity=1000
            fi
            if [ $vmcapacity -gt $capacity ]; then
                capacity=$vmcapacity
            fi
        fi
        echo >> $LICENSE_LOG_FILE
    done

    if [ $capacity == "1000" ]; then
        capacity=1000-HV # change back to its original value
    fi

    if [ $vm_mode == "$SYSD_VM_MODE_VMWARE_HYPERVISOR" -a $capacity != "1000-HV" ]; then
        capacity=0 # set to no license if not 1000-HV in hypervisor mode
    fi

    mkdir -p /etc/cfgdb/dp/vm/

    case "$capacity" in
        "100" )
        echo "Applying VM-100 capacity" >> $LICENSE_LOG_FILE
        cp -f /etc/cfgdb_license/cfgdb.xml.vm100 /etc/cfgdb/dp/vm/cfgdb.xml
        ;;

        "200" )
        echo "Applying VM-200 capacity" >> $LICENSE_LOG_FILE
        cp -f /etc/cfgdb_license/cfgdb.xml.vm200 /etc/cfgdb/dp/vm/cfgdb.xml
        ;;

        "300" )
        echo "Applying VM-300 capacity" >> $LICENSE_LOG_FILE
        cp -f /etc/cfgdb_license/cfgdb.xml.vm300 /etc/cfgdb/dp/vm/cfgdb.xml
        ;;

        "1000-HV" )
        echo "Applying VM-1000-HV capacity" >> $LICENSE_LOG_FILE
        cp -f /etc/cfgdb_license/cfgdb.xml.vm1000-hypervisor /etc/cfgdb/dp/vm/cfgdb.xml
    ;;

        * )
        echo "Applying no license capacity" >> $LICENSE_LOG_FILE
        cp -f /etc/cfgdb_license/cfgdb.xml.nolic /etc/cfgdb/dp/vm/cfgdb.xml
        ;;
    esac
    echo "*** License check done ***" >> $LICENSE_LOG_FILE
}


init_eecfg() {
    # Call set_host_info to set HOST_TYPE, uuid and cpuid
    set_host_info
    case "$HOST_TYPE" in
      *VMware* )
        virt_host="VMware"
        if [ $vm_mode == "$SYSD_VM_MODE_VMWARE_HYPERVISOR" ]; then
            portcount=2
            vm_hypervisor_init
        else
            #check cdrom ready
            if [ $(is_cdrom_ready) == "1" ]; then
                #clean up configuration
                vm_mode=$SYSD_VM_MODE_VMWARE_HYPERVISOR
                /sbin/vm_cfg_init.sh $vm_mode
                portcount=2
                vm_hypervisor_init
            else
                # VMware limits # interfaces to 10, One is reserved for management interface, so configure max portcount as 9.
                vm_mode=$SYSD_VM_MODE_GATEWAY
                portcount=9

                #determine number of vmxnet3 nic interface
                for (( i=0; i<=$portcount; i++ ))
                do
                    ethtool -i eth$i 2> /dev/null  | grep vmxnet3 &> /dev/null
                    if [ $? == 0 ]; then
                        let vmxnet3_nic++
                    fi
                done
            fi
        fi
        ;;
      Xen* | Citrix* )
        # First boot check in xe-daemon
        virt_host="Xen"
        vm_mode=$SYSD_VM_MODE_XEN_SDX
        # Set swap
        swapon /dev/xvda7
        # Xen host configuration is set from xe-daemon because it require network service running
        ;;
      *HYPER* )
        virt_host="Hyper-V"
        ;;
      aws* | amazon* )
        virt_host="AWS"
        is_vm_firstboot
        if [ $? -eq 1 ]; then
            # disable login process on console port
            sed -i "/agetty/s/^/#/" /etc/inittab
            init q
            # Set admin passwd to * and allow only public/private key to login
            sed -i '/admin/c\admin:*:16262:0:99999:7:::' /etc/shadow
            echo "*** PAN VM first time boot - `date` ***" >> $LICENSE_LOG_FILE
            if [ -z "$vm_mode" -o "$vm_mode" != "$SYSD_VM_MODE_XEN_AWS" ]; then
                /usr/bin/xsltproc --output $RUNNING_CFG $AWS_CFG_XSL_FILE $FACTORY_RUNNING_CFG
            fi
            if [ -e ${DO_DATA_RESET} ]; then
              # private data reset, save a copy to vm_cfg
              cp $RUNNING_CFG $VM_INIT_CFG_PATH
            fi
            # Disbale Vlan tagging for SR-IOV driver
            echo "options ixgbevf aws_instance=1" > /etc/modprobe.d/modprobe.conf
            rmmod ixgbevf
            modprobe ixgbevf
        fi
        vm_mode=$SYSD_VM_MODE_XEN_AWS
        portcount=7
        # Set swap
        # swapon /dev/xvde7
        # AWS host configuration is set from xe-daemon because it require network service running
        ;;
      * )
        HOST_TYPE=`virt-what`
        if [ $HOST_TYPE == "kvm" ]; then
            virt_host="KVM"
            vm_mode=$SYSD_VM_MODE_KVM
            cpuid=KVM$cpuid
            if [ -e /dev/vda7 ]; then
                swapon /dev/vda7
            fi

            is_vm_firstboot
            if [ $? -eq 1 ]; then
                # firstboot, check cdrom and process bootstrap file
                echo "*** PAN VM first time boot - `date` ***" >> $LICENSE_LOG_FILE
                check_cdrom
                if [ $? -eq 1 ]; then
                    # bootstrap configuration check
                    if [ -f /mnt/cdrom/$BOOTSTRAP_NETWORK_CFG_FILE ]; then
                        echo "Bootstrap disk is found, start processing..." >> $LICENSE_LOG_FILE
                        mkdir -p $VM_INIT_CFG_PATH >/dev/null 2>&1
                        /usr/bin/xsltproc $VM_INIT_CFG_XSL_FILE /mnt/cdrom/$BOOTSTRAP_NETWORK_CFG_FILE >$VM_INIT_CFG_FILE 2>/dev/null
                        if [ $? -eq 0 ]; then
                            cp -f /mnt/cdrom/$BOOTSTRAP_NETWORK_CFG_FILE $VM_INIT_CFG_PATH/$BOOTSTRAP_NETWORK_CFG_FILE.`date +%Y%m%d` >/dev/null 2>&1

                            # enable network configuration at this moment
                            echo "Enable network configuration from bootstrap file" >> $LICENSE_LOG_FILE
                            IP=`grep ip-address $VM_INIT_CFG_FILE`
                            if [ $? -eq 0 ]; then
                                IP=`echo $IP | cut -d"=" -f 2`
                                NETMASK=`grep netmask $VM_INIT_CFG_FILE | cut -d"=" -f 2`
                                NETMASK=${NETMASK:=255.255.255.0}
                                GW=`grep default-gateway $VM_INIT_CFG_FILE | cut -d"=" -f 2`
                                echo "bootstrap ip: $IP, netmask: $NETMASK, default-gateway: $GW" >> $LICENSE_LOG_FILE
                            else
                                rm -f $VM_INIT_CFG_FILE
                                echo "bootstrap configuration must have <ip-address>." >> $LICENSE_LOG_FILE
                            fi
                        else
                            rm -f $VM_INIT_CFG_FILE
                            echo "Transforming bootstrap file failed. Bootstrap configration won't be applied." >> $LICENSE_LOG_FILE
                        fi
                    fi
                fi
            fi
        else
            virt_host="Unknown"
        fi
        ;;
    esac
}

validate_vm() {
    #Validate core_count, memory, and nic count.
    #Don't run in maint mode.
    if [ ! -f /tmp/maint_mode ]; then
        /sbin/vm_validate $core_count $memory $nic_num $vmxnet3_nic $virt_host $vm_mode $capacity
    fi
}

setup_eecfg() {

    # do initial eeprom file
    cat << EOF > $EECFG
<configdb>
<entry name="platform.family">
        <value>'vm'</value>
</entry>

<entry name="platform.model">
        <value>'PA-VM'</value>
</entry>

<entry name="platform.cores">
        <value>$core_count</value>
</entry>

<entry name="platform.memory">
        <value>$memory</value>
</entry>

<entry name="platform.portcount">
        <value>$portcount</value>
<entry name="platform.virt-host">
        <value>'$virt_host'</value>
</entry>

<entry name="platform.cpuid">
        <value>'$cpuid'</value>
</entry>

<entry name="platform.version">
        <value>'1.0'</value>
</entry>

<entry name="platform.vpn-disable">
        <value>False</value>
</entry>

<entry name="general.vm-mode">
        <value>$vm_mode</value>
</entry>

</configdb>
EOF
}


#
# Only get here for specific platforms
#
case "$1" in
    start)
        [ -e /sbin/ldconfig ] && /sbin/ldconfig
        if [ ! -d /lib64 ]; then
                ln -s /opt/dpfs/lib64 /lib64
        fi
        init_log_file
        init_eecfg
        setup_cfgdb
        validate_vm
        setup_eecfg
        mount -o remount,size=`get_shared_mem_size $vm_mode $memory` /dev/shm
        check_net
        ;;
  stop)
        true;
        ;;
  status)
        /usr/local/bin/sdb 'cfg.platform.*'
        ;;

  *)
            echo $"Usage: $0 {start|stop|status}"
            exit 1
esac

exit $?                                                                                                                                                           
                                                                                                                                                                      